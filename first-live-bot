import ccxt
import numpy as np
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler
import time
import traceback  # Add this import
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')
import joblib
import os

# Configuration
CONTRACT_SIZE = 1000 # Each contract represents 1000 DOGE

API_CREDENTIALS = {
    'api_key': '544d6587-0a7d-4b73-bb06-0e3656c08a18',
    'secret_key': '9C2CA165254391E4B4638DE6577288BD',
    'passphrase': '#Dinywa15'
}

TRADING_CONFIG = {
    'symbol': 'DOGE/USDT:USDT',
    'leverage': 5,
    'timeframe': '15m',
    'historical_limit': 1000,
    'retrain_interval': 60,
    'restart_interval': 12,  # hours
    'model_path': 'trained_model.joblib',
    'min_volume_threshold': 1000000,  # Minimum volume in USDT
    'max_slippage': 0.001,    # 0.1% maximum slippage
    'market_trend_period': 24,  # Number of periods to determine trend
    'cooldown_period': 60,  # seconds between trades
    'extended_cooldown': 450  # longer cooldown after losses (7.5 minutes)
}

RISK_CONFIG = {
    'max_position_size': 1.0,
    'stop_loss_pct': 0.02,      # 2% stop loss
    'take_profit_pct': 0.04,    # 4% take profit
    'min_confidence': 0.6,
    'trailing_stop_pct': 0.015, # 1.5% trailing stop (increased from 1%)
    'min_profit_exit': 0.015,   # 1.5% minimum profit to start trailing
    'max_loss_threshold': 0.1 # 10 % max loss threshold 
}

# Indicator calculation functions
def calculate_hull_ma(df, period=14):
    half_period = int(period/2)
    sqrt_period = int(np.sqrt(period))
    
    weighted_data = pd.DataFrame(index=df.index)
    weighted_data['half_period'] = df['Close'].rolling(window=half_period).apply(
        lambda x: np.average(x, weights=range(1, len(x)+1))
    )
    weighted_data['full_period'] = df['Close'].rolling(window=period).apply(
        lambda x: np.average(x, weights=range(1, len(x)+1))
    )
    weighted_data['raw_hma'] = 2 * weighted_data['half_period'] - weighted_data['full_period']
    hull_ma = weighted_data['raw_hma'].rolling(window=sqrt_period).mean()
    return hull_ma

def calculate_ichimoku(df):
    high_values = df['High']
    low_values = df['Low']
    
    tenkan_high = high_values.rolling(window=9).max()
    tenkan_low = low_values.rolling(window=9).min()
    tenkan_sen = (tenkan_high + tenkan_low) / 2
    
    kijun_high = high_values.rolling(window=26).max()
    kijun_low = low_values.rolling(window=26).min()
    kijun_sen = (kijun_high + kijun_low) / 2
    
    senkou_span_a = ((tenkan_sen + kijun_sen) / 2).shift(26)
    
    senkou_high = high_values.rolling(window=52).max()
    senkou_low = low_values.rolling(window=52).min()
    senkou_span_b = ((senkou_high + senkou_low) / 2).shift(26)
    
    return pd.DataFrame({
        'tenkan_sen': tenkan_sen,
        'kijun_sen': kijun_sen,
        'senkou_span_a': senkou_span_a,
        'senkou_span_b': senkou_span_b
    })

def calculate_stoch_rsi(df, period=14, smooth_k=3, smooth_d=3):
    close_delta = df['Close'].diff()
    gains = close_delta.where(close_delta > 0, 0)
    losses = -close_delta.where(close_delta < 0, 0)
    
    avg_gain = gains.rolling(window=period).mean()
    avg_loss = losses.rolling(window=period).mean()
    
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    
    stoch_rsi = pd.DataFrame()
    stoch_rsi['k'] = ((rsi - rsi.rolling(period).min()) / 
                      (rsi.rolling(period).max() - rsi.rolling(period).min())).rolling(smooth_k).mean() * 100
    stoch_rsi['d'] = stoch_rsi['k'].rolling(smooth_d).mean()
    return stoch_rsi

def calculate_supertrend(df, period=10, multiplier=3):
    hl2 = (df['High'] + df['Low']) / 2
    atr = df['High'].sub(df['Low']).rolling(period).mean()
    
    # Calculate basic upper and lower bands
    basic_ub = hl2 + (multiplier * atr)
    basic_lb = hl2 - (multiplier * atr)
    
    # Initialize final upper and lower bands
    final_ub = basic_ub.copy()
    final_lb = basic_lb.copy()
    
    # Calculate final upper and lower bands
    for i in range(period, len(df)):
        final_ub[i] = basic_ub[i] if (
            basic_ub[i] < final_ub[i-1] or df['Close'][i-1] > final_ub[i-1]
        ) else final_ub[i-1]
        
        final_lb[i] = basic_lb[i] if (
            basic_lb[i] > final_lb[i-1] or df['Close'][i-1] < final_lb[i-1]
        ) else final_lb[i-1]
    
    # Calculate SuperTrend
    supertrend = pd.Series(1, index=df.index)
    for i in range(period, len(df)):
        supertrend[i] = 1 if df['Close'][i] > final_ub[i] else -1 if df['Close'][i] < final_lb[i] else supertrend[i-1]
    
    return supertrend

def calculate_volatility(df, window=20):
    return df['Close'].pct_change().rolling(window=window).std()

def calculate_trend_strength(df, period=14):
    # Calculate directional movement
    plus_dm = df['High'].diff()
    minus_dm = -df['Low'].diff()
    plus_dm = plus_dm.where(plus_dm > 0, 0)
    minus_dm = minus_dm.where(minus_dm > 0, 0)
    
    # Calculate true range
    tr = pd.DataFrame([
        df['High'] - df['Low'],
        abs(df['High'] - df['Close'].shift(1)),
        abs(df['Low'] - df['Close'].shift(1))
    ]).max()
    
    # Smoothed calculations
    tr_smoothed = tr.ewm(span=period).mean()
    plus_di = 100 * plus_dm.ewm(span=period).mean() / tr_smoothed
    minus_di = 100 * minus_dm.ewm(span=period).mean() / tr_smoothed
    
    # Calculate ADX
    dx = 100 * abs(plus_di - minus_di) / (plus_di + minus_di)
    adx = dx.ewm(span=period).mean() / 100  # Normalized to 0-1
    return adx

def calculate_ultimate_oscillator(df, period1=7, period2=14, period3=28):
    # True Range
    tr = pd.DataFrame()
    tr['h_l'] = df['High'] - df['Low']
    tr['h_pc'] = abs(df['High'] - df['Close'].shift(1))
    tr['l_pc'] = abs(df['Low'] - df['Close'].shift(1))
    tr['tr'] = tr[['h_l', 'h_pc', 'l_pc']].max(axis=1)
    
    # Buying Pressure
    bp = df['Close'] - pd.DataFrame([df['Low'], df['Close'].shift(1)]).min()
    
    # Average True Range calculations
    avg7 = bp.rolling(period1).sum() / tr['tr'].rolling(period1).sum()
    avg14 = bp.rolling(period2).sum() / tr['tr'].rolling(period2).sum()
    avg28 = bp.rolling(period3).sum() / tr['tr'].rolling(period3).sum()
    
    # Ultimate Oscillator calculation
    uo = 100 * ((4 * avg7 + 2 * avg14 + avg28) / 7)
    return uo

def calculate_aroon(df, period=25):
    aroon = pd.DataFrame()
    aroon['aroon_up'] = 100 * df['High'].rolling(period + 1).apply(
        lambda x: float(np.argmax(x)) / period
    )
    aroon['aroon_down'] = 100 * df['Low'].rolling(period + 1).apply(
        lambda x: float(np.argmin(x)) / period
    )
    return aroon

def calculate_elder_ray(df, period=13):
    ema = df['Close'].ewm(span=period, adjust=False).mean()
    elder = pd.DataFrame()
    elder['bull_power'] = df['High'] - ema
    elder['bear_power'] = df['Low'] - ema
    return elder

class MLTradingBot:
    def __init__(self):
        # Initialize exchange connection with proper sandbox configuration
        self.exchange = ccxt.okx({
            'apiKey': API_CREDENTIALS['api_key'],
            'secret': API_CREDENTIALS['secret_key'],
            'password': API_CREDENTIALS['passphrase'],
            'enableRateLimit': True,
            'sandboxMode': True,
            'options': {
                'defaultType': 'swap',  # For futures trading
                'createMarketBuyOrderRequiresPrice': False
            }
        })
        
        # Ensure sandbox mode is properly set
        self.exchange.set_sandbox_mode(True)
        
        try:
            # Test authentication
            self.exchange.check_required_credentials()
            # Load markets without fetching currencies
            self.exchange.loadMarkets(True)
            
            # Initialize trading parameters
            self.symbol = TRADING_CONFIG['symbol']
            self.leverage = TRADING_CONFIG['leverage']
            self.timeframe = TRADING_CONFIG['timeframe']
            
            # Initialize ML model with loading capability
            self.model_path = TRADING_CONFIG['model_path']
            if os.path.exists(self.model_path):
                print("Loading existing trained model...")
                self.model = joblib.load(self.model_path)
            else:
                print("Initializing new model...")
                self.model = RandomForestClassifier(n_estimators=100, random_state=42)
            
            self.start_time = datetime.now()
            self.scaler = StandardScaler()
            
            print(f"Bot initialized with {self.symbol} on {self.timeframe} timeframe")
            
        except Exception as e:
            print(f"Initialization error: {str(e)}")
            raise e

        self.peak_price = None
        self.entry_price = None
        self.last_high = None
        self.trailing_stop_price = None
        self.trades_history = []
        self.performance_metrics = {
            'total_trades': 0,
            'winning_trades': 0,
            'total_pnl': 0,
            'max_drawdown': 0
        }
        self.last_trade_time = None
        self.last_trade_result = None

    def save_model(self):
        """Save the trained model to disk"""
        if hasattr(self.model, 'classes_'):
            joblib.dump(self.model, self.model_path)
            print("Model saved successfully")

    def should_restart(self):
        """Check if bot should restart based on time"""
        elapsed_time = datetime.now() - self.start_time
        return elapsed_time.total_seconds() / 3600 >= TRADING_CONFIG['restart_interval']

    def prepare_features(self, df):
        try:
            # Calculate all indicators
            df = self.calculate_all_indicators(df)
            
            # Select and clean features
            feature_columns = [
                'Hull_MA', 'ichimoku_tenkan', 'ichimoku_kijun',
                'stoch_rsi_k', 'stoch_rsi_d', 'ultimate_oscillator',
                'kst', 'elder_bull', 'elder_bear', 'aroon_up',
                'aroon_down', 'supertrend'
            ]
            
            X = pd.DataFrame()
            for col in feature_columns:
                if col in df.columns:
                    series = df[col].replace([np.inf, -np.inf], np.nan)
                    X[col] = series.fillna(method='ffill').fillna(0)
            
            # Add trend and volatility features
            X['trend_strength'] = calculate_trend_strength(df)
            X['volatility'] = calculate_volatility(df)
            
            # Scale features
            for col in X.columns:
                max_val = abs(X[col]).max()
                if max_val > 0:
                    X[col] = X[col] / max_val
            
            return X.values
        except Exception as e:
            print(f"Feature preparation error: {str(e)}")
            raise e

    def calculate_all_indicators(self, df):
        try:
            # Calculate basic indicators
            df['Hull_MA'] = calculate_hull_ma(df)
            ichimoku = calculate_ichimoku(df)
            df['ichimoku_tenkan'] = ichimoku['tenkan_sen']
            df['ichimoku_kijun'] = ichimoku['kijun_sen']
            
            # Calculate momentum indicators
            stoch_rsi = calculate_stoch_rsi(df)
            df['stoch_rsi_k'] = stoch_rsi['k']
            df['stoch_rsi_d'] = stoch_rsi['d']
            df['ultimate_oscillator'] = calculate_ultimate_oscillator(df)
            
            # Calculate additional indicators
            df['supertrend'] = calculate_supertrend(df)
            elder = calculate_elder_ray(df)
            df['elder_bull'] = elder['bull_power']
            df['elder_bear'] = elder['bear_power']
            aroon = calculate_aroon(df)
            df['aroon_up'] = aroon['aroon_up']
            df['aroon_down'] = aroon['aroon_down']
            
            return df
            
        except Exception as e:
            print(f"Indicator calculation error: {str(e)}")
            raise e

    def detect_market_peak(self, df, lookback=5):
        """Detect if we're near a market peak"""
        recent_prices = df['Close'].tail(lookback)
        current_price = recent_prices.iloc[-1]
        
        # Check if current price is highest in lookback period
        is_local_peak = current_price == recent_prices.max()
        
        # Check momentum and rate of change
        momentum = calculate_trend_strength(df)
        roc = df['Close'].pct_change(periods=3).iloc[-1]
        
        # RSI for overbought/oversold conditions
        rsi = calculate_stoch_rsi(df)['k'].iloc[-1]
        
        return {
            'is_peak': is_local_peak and rsi > 80 and momentum > 0.7,
            'momentum': momentum,
            'rsi': rsi
        }

    def should_exit_position(self, current_price, position):
        """Determine if we should exit the position"""
        if not self.entry_price:
            return False
            
        # Update peak price if we have a new high
        if not self.peak_price or current_price > self.peak_price:
            self.peak_price = current_price
            # Update trailing stop
            if position['side'] == 'long':
                self.trailing_stop_price = self.peak_price * (1 - RISK_CONFIG['trailing_stop_pct'])
            else:
                self.trailing_stop_price = self.peak_price * (1 + RISK_CONFIG['trailing_stop_pct'])

        # Calculate current P&L
        pnl_pct = (current_price - self.entry_price) / self.entry_price
        if position['side'] == 'short':
            pnl_pct = -pnl_pct

        # Exit conditions
        exit_conditions = {
            'trailing_stop_hit': self.trailing_stop_price and (
                (position['side'] == 'long' and current_price < self.trailing_stop_price) or
                (position['side'] == 'short' and current_price > self.trailing_stop_price)
            ),
            'stop_loss_hit': abs(pnl_pct) < -RISK_CONFIG['stop_loss_pct'],
            'take_profit_hit': pnl_pct > RISK_CONFIG['take_profit_pct'],
            'max_loss_threshold': pnl_pct < -RISK_CONFIG['max_loss_threshold']
        }

        should_exit = any(exit_conditions.values())
        if should_exit:
            reason = next(k for k, v in exit_conditions.items() if v)
            print(f"Exit signal: {reason} - P&L: {pnl_pct:.4%}")
        
        return should_exit

    def check_cooldown(self):
        """Check if enough time has passed since last trade"""
        if not self.last_trade_time:
            return True
            
        current_time = time.time()
        time_since_last_trade = current_time - self.last_trade_time
        
        # Use longer cooldown if last trade was a loss
        required_cooldown = (TRADING_CONFIG['extended_cooldown'] 
                           if self.last_trade_result and self.last_trade_result < 0 
                           else TRADING_CONFIG['cooldown_period'])
        
        if time_since_last_trade < required_cooldown:
            minutes_left = (required_cooldown - time_since_last_trade) / 60
            print(f"Cooling off... {minutes_left:.1f} minutes remaining")
            return False
            
        return True

    def execute_trade(self, signal, confidence):
        try:
            # Check cooldown first
            if not self.check_cooldown():
                return
                
            # Get current position details
            positions = self.exchange.fetch_positions([self.symbol])
            current_position = None
            for pos in positions:
                if pos['symbol'] == self.symbol and float(pos['contracts']) != 0:
                    current_position = pos
                    break

            # Get current market data
            ticker = self.exchange.fetch_ticker(self.symbol)
            current_price = float(ticker['last'])

            # Check if we should exit existing position
            if current_position:
                if self.should_exit_position(current_price, current_position):
                    print(f"Closing position at {current_price}")
                    close_order = self.exchange.create_order(
                        self.symbol,
                        'market',
                        'buy' if current_position['side'] == 'short' else 'sell',
                        abs(float(current_position['contracts'])),
                        params={
                            'posSide': current_position['side'],
                            'reduceOnly': True
                        }
                    )
                    print(f"Position closed: {close_order['id']}")
                    self.peak_price = None
                    self.entry_price = None
                    self.trailing_stop_price = None
                    time.sleep(2)
                    return

            # Add cooldown period between trades
            if hasattr(self, 'last_trade_time'):
                time_since_last_trade = time.time() - self.last_trade_time
                if time_since_last_trade < 300:  # 5 minute cooldown
                    print(f"Skipping trade - cooldown period ({time_since_last_trade:.0f}s < 300s)")
                    return
            
            # Handle existing position
            if current_position:
                # Only close position if signal is opposite to current position
                current_side = current_position['side']
                if (signal > 0 and current_side == 'short') or (signal < 0 and current_side == 'long'):
                    print(f"Closing existing {current_side} position of {current_position['contracts']} contracts")
                    close_order = self.exchange.create_order(
                        self.symbol,
                        'market',
                        'buy' if current_side == 'short' else 'sell',
                        abs(float(current_position['contracts'])),
                        params={
                            'posSide': current_side,
                            'reduceOnly': True
                        }
                    )
                    print(f"Position closed: {close_order['id']}")
                    time.sleep(2)  # Wait for position to close
                else:
                    print(f"Keeping existing {current_side} position as signal agrees with position")
                    return
            
            # Calculate and execute new position
            if abs(confidence) > RISK_CONFIG['min_confidence']:
                desired_contracts = self.calculate_position_size(confidence, signal)
                if abs(desired_contracts) >= 0.01:  # Minimum contract size
                    side = 'buy' if signal > 0 else 'sell'
                    pos_side = 'long' if signal > 0 else 'short'
                    
                    order = self.exchange.create_order(
                        self.symbol,
                        'market',
                        side,
                        abs(desired_contracts),
                        params={
                            'posSide': pos_side,
                            'tdMode': 'cross'
                        }
                    )
                    print(f"New position opened: {side.upper()} {abs(desired_contracts)} contracts")
                    self.last_trade_time = time.time()

                    # Update entry price when opening new position
                    self.entry_price = current_price
                    self.peak_price = current_price
                    if signal > 0:
                        self.trailing_stop_price = current_price * (1 - RISK_CONFIG['trailing_stop_pct'])
                    else:
                        self.trailing_stop_price = current_price * (1 + RISK_CONFIG['trailing_stop_pct'])
            
        except Exception as e:
            print(f"Trade execution error: {str(e)}")
            print("Stack trace:", traceback.format_exc())

    def calculate_position_size(self, confidence, signal):
        try:
            balance = self.exchange.fetch_balance()
            usdt_balance = float(balance['total']['USDT'])
            ticker = self.exchange.fetch_ticker(self.symbol)
            current_price = float(ticker['last'])
            
            # Calculate position size based on balance and risk parameters
            risk_amount = usdt_balance * RISK_CONFIG['max_position_size']
            leveraged_amount = risk_amount * self.leverage
            
            # Scale by confidence
            position_value = leveraged_amount * abs(confidence)
            contracts = (position_value / current_price) / CONTRACT_SIZE
            
            return round(contracts * signal, 4)  # Round to 4 decimal places
            
        except Exception as e:
            print(f"Position size calculation error: {str(e)}")
            return 0

    def check_market_conditions(self, df):
        """Check if market conditions are suitable for trading"""
        try:
            # Check volume
            recent_volume = df['Volume'].tail(5).mean() * df['Close'].iloc[-1]
            if recent_volume < TRADING_CONFIG['min_volume_threshold']:
                print(f"Volume too low: {recent_volume:.2f} USDT")
                return False

            # Check market trend
            trend_period = TRADING_CONFIG['market_trend_period']
            ma_short = df['Close'].rolling(window=trend_period//2).mean()
            ma_long = df['Close'].rolling(window=trend_period).mean()
            current_trend = 'uptrend' if ma_short.iloc[-1] > ma_long.iloc[-1] else 'downtrend'
            
            # Check volatility
            current_volatility = calculate_volatility(df).iloc[-1]
            avg_volatility = calculate_volatility(df).mean()
            
            print(f"Market conditions - Trend: {current_trend}, Volatility: {current_volatility:.4f}")
            return True
            
        except Exception as e:
            print(f"Error checking market conditions: {str(e)}")
            return False

    def update_performance_metrics(self, trade_result):
        """Update bot performance metrics"""
        self.performance_metrics['total_trades'] += 1
        if trade_result['pnl'] > 0:
            self.performance_metrics['winning_trades'] += 1
        self.performance_metrics['total_pnl'] += trade_result['pnl']
        
        # Calculate win rate and other metrics
        win_rate = (self.performance_metrics['winning_trades'] / 
                   self.performance_metrics['total_trades'] * 100)
        
        print("\n=== Performance Metrics ===")
        print(f"Total Trades: {self.performance_metrics['total_trades']}")
        print(f"Win Rate: {win_rate:.2f}%")
        print(f"Total PnL: {self.performance_metrics['total_pnl']:.4f} USDT")
        print("=========================\n")

    def run(self):
        print("Starting OKX Trading Bot...")
        last_training_time = None
        training_interval = 3600  # Retrain every hour
        
        while True:
            try:
                # Check for restart condition
                if self.should_restart():
                    print("Scheduled restart: Saving model and exiting...")
                    self.save_model()
                    return
                
                # Fetch and prepare data
                ohlcv = self.exchange.fetch_ohlcv(
                    self.symbol,
                    self.timeframe,
                    limit=TRADING_CONFIG['historical_limit']
                )
                
                df = pd.DataFrame(ohlcv, columns=['Timestamp', 'Open', 'High', 'Low', 'Close', 'Volume'])
                df['Timestamp'] = pd.to_datetime(df['Timestamp'], unit='ms')
                df = df.set_index('Timestamp')
                
                if df.empty:
                    print("No data received, waiting...")
                    time.sleep(60)
                    continue
                
                # Convert and clean data
                for col in ['Open', 'High', 'Low', 'Close', 'Volume']:
                    df[col] = df[col].astype(float)
                
                if df.isnull().any().any():
                    print("Warning: Missing values in data")
                    df = df.fillna(method='ffill').fillna(method='bfill')
                
                # Prepare features
                features = self.prepare_features(df)
                
                # Check if we need to train or retrain the model
                current_time = time.time()
                should_train = (
                    not hasattr(self.model, 'classes_') or
                    (last_training_time and current_time - last_training_time > training_interval)
                )
                
                if should_train:
                    print("Training model...")
                    labels = (df['Close'].shift(-1) > df['Close']).astype(int)[:-1]
                    self.model.fit(features[:-1], labels)
                    self.save_model()
                    last_training_time = current_time
                    print("Training completed, continuing trading...")
                
                # Make predictions and execute trades
                prediction = self.model.predict(features[-1:])
                confidence = max(self.model.predict_proba(features[-1:])[0])
                
                print(f"Prediction: {'LONG' if prediction[0] == 1 else 'SHORT'} | Confidence: {confidence:.4f}")
                
                if confidence > RISK_CONFIG['min_confidence']:
                    signal = 1 if prediction[0] == 1 else -1
                    self.execute_trade(signal, confidence)
                else:
                    print(f"Confidence too low ({confidence:.4f} < {RISK_CONFIG['min_confidence']}), skipping trade")
                
                # Store current DataFrame and update metrics
                self.current_df = df
                if self.performance_metrics['total_trades'] > 0 and \
                   self.performance_metrics['total_trades'] % 10 == 0:
                    self.save_performance_metrics()
                
                time.sleep(60)
                
            except Exception as e:
                print(f"Error in main loop: {str(e)}")
                print("Stack trace:", traceback.format_exc())
                time.sleep(60)

    def save_performance_metrics(self):
        """Save performance metrics to file"""
        try:
            metrics_file = f'performance_metrics_{datetime.now().strftime("%Y%m%d")}.json'
            with open(metrics_file, 'w') as f:
                json.dump(self.performance_metrics, f, indent=4)
            print(f"Performance metrics saved to {metrics_file}")
        except Exception as e:
            print(f"Error saving metrics: {str(e)}")

if __name__ == "__main__":
    while True:
        try:
            bot = MLTradingBot()
            bot.run()
            print("Bot restarting...")
            time.sleep(5)  # Brief pause before restart
        except Exception as e:
            print(f"Critical error: {str(e)}")
            time.sleep(300)  # 5-minute wait on critical error
